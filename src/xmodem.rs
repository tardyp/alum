// This module needs to take a file path, read its contents into
// memory, and send out packets. I don't know how the packet sending
// should be done at this point.

// It also needs to work with 1024- and 128-byte packets, for the
// XModem server.
use hxdmp::hexdump;
use std::fs::File;
use std::io::Write;
use std::path::PathBuf;
use std::thread;
use std::time::Duration;
use anyhow::{Context, Result};
use console::style;
use serialport;

fn print_hexdump(data: &[u8]) {
    let mut buf = Vec::new();
    hexdump(&data, &mut buf).unwrap();
    println!("{}", String::from_utf8_lossy(&buf));
}
#[derive(PartialEq)]
enum ChecksumMode {
    Normal,
    Conn4x,
}

const SOH: u8 = 0x01;
const STX: u8 = 0x02;
const EOT: u8 = 0x04;
const ACK: u8 = 0x06;
const NAK: u8 = 0x15;
const CAN: u8 = 0x18;
// XModem is supposed to use 0x1a, but the HP uses 0x00.
const SUB: u8 = 0x00; //0x1a; // used as packet filler, ascii code SUB (substitute)

// packet_count_offset is an adjustment to the packet-counting loop
// inside this function. For example, if the offset is 3, then the
// first packet generated by this loop will have packet number 4
// (XModem uses 1-indexed packet numbers). As such, 1 may need to be
// added to the offset to get the desired outcome.
fn data_to_128_packets(
    data: &Vec<u8>,
    packet_count_offset: usize,
    checksum_mode: ChecksumMode,
) -> Vec<Vec<u8>> {
    let mut packet_list = Vec::new();
    // generated even when in normal checksum mode, because it's fast
    // and might be used in the loop.
    let crc_array: [u32; 256] = init_crc_array();

    // If we always add 1 (in the calling function), we'll end up with
    // a scenario where the first packet will have a sequence number
    // of 2 instead of 1. This is mostly an issue for an object that's
    // less than 1024 bytes.

    // Round up packet count because any remaining data still has to
    // fit in a packet.
    let packet_count = crate::helpers::div_up(data.len(), 128);

    // Begin assembling packets
    for i in 0..packet_count {
        // One XModem 128-byte packet contains 128 bytes of data, plus
        // 4 metadata bytes.
        let mut packet = Vec::new();
        let mut checksum = 0u32;

        packet.push(SOH);
        // sequence number, when encoded in packet uses 1-indexing.
        // doing the addition this way should prevent overflow errors.
        let seq = (i + 1 + packet_count_offset) as u8;
        packet.push(seq);
        // 1's complement of the sequence number
        packet.push(255u8 - (255u8 & seq));

        // If we're on the last packet (packet_count - 1), go to the end of the file.
        // Otherwise, we'll end up reading past the end of the file and get an error.
        let loop_limit = {
            if i == packet_count - 1 {
                data.len() % 128
            } else {
                128
            }
        };

        for j in 0..loop_limit {
            let byte = *data.get(i * 128 + j).expect("File unexpectedly cut short!");
            if checksum_mode == ChecksumMode::Normal {
                checksum += byte as u32;
            }
            packet.push(byte);
        }

        // fill rest of packet if necessary
        if loop_limit != 128 {
            for _ in loop_limit..128 {
                if checksum_mode == ChecksumMode::Normal {
                    checksum += SUB as u32;
                }
                packet.push(SUB);
            }
        }

        // get lowest byte of checksum
        if checksum_mode == ChecksumMode::Conn4x {
            // calculate Conn4x checksum and get two lowest bytes
            let crc = crc_conn4x(crc_array, packet[3..].to_vec());
            packet.push(((crc & 0xff00u32) >> 8) as u8);
            packet.push((crc & 0xffu32) as u8);
        } else {
            // get lowest byte of checksum
            packet.push((checksum & 0xffu32) as u8);
        }
        packet_list.push(packet);
    }

    return packet_list;
}

// Converted straight from Conn4x source. This is not standard with
// the CCITT CRC calculation.

// The Conn4x CRC is identical to the HP's internal CRC algorithm. I
// implement this in hp_object.rs, however, my implementation works on
// individual nibbles at a time. This version, with a CRC table, works
// on bytes.
fn init_crc_array() -> [u32; 256] {
    let mut crc_array: [u32; 256] = [0; 256];
    let mut i = 0usize;
    for crc in 0..16 {
        for inp in 0..16 {
            crc_array[i] = (crc ^ inp) * 0x1081;
            i += 1;
        }
    }
    return crc_array;
}

fn crc_conn4x(crc_array: [u32; 256], data: Vec<u8>) -> u32 {
    let mut result = 0u32;
    for e in data.iter() {
        let mut k = (result & 0xf) << 4;
        result = (result >> 4) ^ crc_array[(k as u32 + (*e as u32 & 0xfu32)) as usize];
        k = (result & 0xf) << 4;
        result = (result >> 4) ^ crc_array[(k as u32 + (*e as u32 >> 4u32)) as usize];
    }

    return result;
}

// Generate a list of XModem packets with Conn4x checksums. This will
// try to make 1K-byte packets, then make 128-byte packets with the
// remaining data.
fn data_to_conn4x_packets(data: &Vec<u8>) -> Vec<Vec<u8>> {
    let mut packet_list = Vec::new();
    let crc_array: [u32; 256] = init_crc_array();
    // Number of 1K-byte packets to use
    let mut packet_offset = 0usize;
    let packet_count = data.len() / 1024;
    //println!("data.len() is {:?}, packet_count in conn4x_packets is {:?}", data.len(), packet_count);
    for i in 0..packet_count {
        packet_offset += 1;

        let mut packet = Vec::new();

        packet.push(STX); // STX used to indicate 1K-byte block
        let packet_count = (i + 1) as u8;
        packet.push(packet_count);
        packet.push(255u8 - (255u8 & packet_count as u8));

        // We will always push 1024 in this loop, smaller amounts are
        // relegated to data_to_128_packets
        for j in 0..1024 {
            let byte = *data
                .get(i * 1024 + j)
                .expect("File unexpectedly cut short!");
            packet.push(byte);
        }

        // run CRC on the data portion of the packet
        let crc = crc_conn4x(crc_array, (&packet[3..]).to_vec());
        packet.push(((crc & 0xff00u32) >> 8) as u8);
        packet.push((crc & 0xffu32) as u8);

        packet_list.push(packet);
    }

    // get what remains of the data, this is just everything after the
    // last 1K packet.
    let mut substr_128 = Vec::new();
    for i in &data[packet_count * 1024..] {
        substr_128.push(*i);
    }

    let mut packets_128 = data_to_128_packets(&substr_128, packet_offset, ChecksumMode::Conn4x);
    // Append both vectors together for the final list
    packet_list.append(&mut packets_128);

    return packet_list;
}

// Looks for ack_char on `port`, returns true if char found or false if NAK found.
fn wait_for_char(port: &mut Box<dyn serialport::SerialPort>, ack_char: u8) -> u8 {
    let mut buf: [u8; 1] = [0; 1];
    loop {
        match port.read(buf.as_mut_slice()) {
            Ok(_) => {
                let byte = *buf.get(0).unwrap();
                if byte == ack_char {
                    break;
                } else {
                    return byte;
                }
            }
            Err(e) => crate::helpers::error_handler(format!(
                "Error: failed to read from serial port: {:?}",
                e
            )),
        }

        //println!("waiting for ACK");
    }
    return ack_char;
}
fn getc(port: &mut Box<dyn serialport::SerialPort>) -> Result<u8> {
	let mut buf: [u8; 1] = [0; 1];
	port.read(buf.as_mut_slice()).context("Error: failed to read from serial port.")?;
	Ok(*buf.get(0).unwrap())
}
fn putc(port: &mut Box<dyn serialport::SerialPort>, c: u8) -> Result<()> {
	let buf: [u8; 1] = [c];
	port.write(&buf).context("Error: failed to write to serial port.")?;
	Ok(())
}
// The way packets are sent and responses are handled don't change.

fn send_packets(packet_list: &Vec<Vec<u8>>, port: &mut Box<dyn serialport::SerialPort>) {
    let pb = crate::helpers::get_progress_bar(packet_list.len() as u64);

    for (pos, packet) in packet_list.iter().enumerate() {
        let mut retry_count = 0;
        match port.write(packet) {
            Ok(_) => {}
            Err(e) => {
                crate::helpers::error_handler(format!("Error: failed to write packet {:?}", e))
            }
        }

        // wait for ACK on current packet
        let c = wait_for_char(port, ACK);
        //println!("c is {:?}", c);
        if c == NAK {
            match port.write(packet) {
                Ok(_) => {}
                Err(e) => crate::helpers::error_handler(format!(
                    "Error: failed to read char for packet {:?}: {:?}",
                    pos, e
                )),
            }
            retry_count += 1;
            if retry_count == 3 {
                // Something deeper is wrong, give up
                crate::helpers::error_handler(format!(
                    "Error: failed on packet {:?} after 3 tries, giving up.",
                    pos
                ));
            }
        } else if c == CAN {
            // cancel, just exit.
            pb.abandon();
            crate::helpers::error_handler("Error: transfer cancelled by calculator.".to_string());
        } else if c == ACK {
            // on ACK, increment and check if we need to send EOT
            pb.inc(1);
            // if we successfully sent the last packet, send EOT after the
            // last ACK. This will trigger another ACK, which we look for
            // below (but probably don't need to)
            if pos == packet_list.len() - 1 {
                //println!("sending EOT");
                let wr_buf: [u8; 1] = [EOT];
                match port.write(&wr_buf) {
                    Ok(_) => {}
                    Err(e) => {
                        crate::helpers::error_handler(format!("Error: failed to send EOT: {:?}", e))
                    }
                }
                wait_for_char(port, ACK);
            }
        } else {
            pb.abandon();
            crate::helpers::error_handler(
                "Error: unexpected character during transfer.".to_string(),
            );
        }
    }
    // make the progress bar visible on screen
    pb.finish();
}

fn finish_server(port: &mut Box<dyn serialport::SerialPort>) {
    // needed to make Q actually work
    thread::sleep(Duration::from_millis(300));
    // send Q to server, which tells server to exit
    let buf: [u8; 1] = ['Q' as u8];
    match port.write(&buf) {
        Ok(_) => {}
        Err(e) => crate::helpers::error_handler(format!("error writing packet: {:?}", e)),
    };
}
// Send `path` to the calculator with Conn4x-style XModem.
pub fn send_file_conn4x(path: &PathBuf, port: &mut Box<dyn serialport::SerialPort>, finish: &bool) {
    let file_contents = crate::helpers::get_file_contents(path);

    let packet_list = data_to_conn4x_packets(&file_contents);

    let fname = path.file_name().unwrap().to_str().unwrap();
    let mut hp_fname: Vec<u8> = Vec::new();
    for i in fname.chars() {
        hp_fname.push(crate::helpers::char_to_hp_char(i));
    }

    match port.write(&create_command_packet(hp_fname, 'P')) {
        Ok(_) => {}
        Err(e) => crate::helpers::error_handler(format!("error writing packet: {:?}", e)),
    };

    wait_for_char(port, ACK);

    // XModem Server sends D to indicate that it's ready for a
    // Conn4x-style XModem transfer
    wait_for_char(port, 'D' as u8);

    // Now send packet_list to the serialport
    send_packets(&packet_list, port);
    if *finish {
        finish_server(port);
    }
}

pub fn send_file_normal(path: &PathBuf, port: &mut Box<dyn serialport::SerialPort>) {
    let file_contents = crate::helpers::get_file_contents(path);

    wait_for_char(port, NAK);

    let packet_list = data_to_128_packets(&file_contents, 0, ChecksumMode::Normal);
    //println!("{:?}", &packet_list[0..256]);
    send_packets(&packet_list, port);
}

// This function creates a "command packet" for the XModem server. It
// also adds the initial command to the entire Vec<u8>. See my XModem
// server documentation for more information about this.
fn create_command_packet(data: Vec<u8>, cmd: char) -> Vec<u8> {
    let mut cmd_packet: Vec<u8> = Vec::new();
    cmd_packet.push(cmd as u8);
    cmd_packet.push(((data.len() as u32 & 0xff00u32) >> 8) as u8);
    cmd_packet.push(data.len() as u8);
    let mut checksum = 0u32;
    // You can't iterate over an OsStr because it might contain
    // different encodings, so you have to convert it. You can iterate
    // over a &str, which to_str() creates.
    for c in data {
        //.to_str().unwrap().chars() {
        cmd_packet.push(c); // as u8);
        checksum += c as u32;
    }

    cmd_packet.push(checksum as u8);

    return cmd_packet;
}

// The directory `fixit` ends with an INTENTIONAL 0x00 byte. What does
// the XModem server do with it?

// The XModem server breaks the file, like we do. The 0x00 byte is
// replaced with 0x30 (who knows why...), and sending the same file to
// the calculator maintains the 0x30 byte, which is incorrect. This is
// a limitation of the XModem protocol. Moral of the story: check the
// checksums if you use XModem. (though for my money, the XModem
// server should use standard 0x1a instead of 0x00 for the extra
// bytes).

// The server always sends 128-byte packets even if the file is big
// enough for 1K XModem.

// (likely incorrect) Conn4x will do something to a real number and add an extra 00
// bytes if needed. Without this byte, a positive real number will
// become correct.
pub fn get_file(
    path: &PathBuf,
    port: &mut Box<dyn serialport::SerialPort>,
    direct: &bool,
    overwrite: &bool,
    finish: &bool,
) -> Result<PathBuf> {
    let final_path = match overwrite {
        true => path.to_path_buf(),
        false => crate::helpers::get_unique_path(path.to_path_buf()),
    };
    println!("final_path in get_file is {:?}", final_path);
    // original_fname is the filename only of the path passed to the code
    // final_fname is the filename only of the path we're writing to
    let original_fname = path.file_name().unwrap().to_str().unwrap();
    let final_fname = final_path.file_name().unwrap().to_str().unwrap();

    let mut file = File::create(&final_path).unwrap();

    // hp_fname is the list of bytes we actually send to the calculator, with HP 48 byte conversion
    let mut hp_fname: Vec<u8> = Vec::new();

    // we can transfer files with special characters but they have to be in HP 48 byte format, not UTF-8.
    for i in original_fname.chars() {
        hp_fname.push(crate::helpers::char_to_hp_char(i));
    }

    let pb = crate::helpers::get_spinner(format!(
        "Receiving {} as {} from {}...",
        style(original_fname).yellow().bright(),
        style(final_fname).yellow().bright(),
        style(port.name().unwrap()).green().bright()
    ));

    // We push to a Vec<u8> then write to the file.
    let mut file_contents: Vec<u8> = Vec::new();

    if !direct {
        // Tell XModem server to send file
        port.write(&create_command_packet(hp_fname, 'G')).context("Error: failed to write command packet.")?;
        // Wait for ACK from server about command
		let c = wait_for_char(port, ACK);
        if c != ACK {
			return Err(anyhow::anyhow!("Error: got {:?} from server when sending 'get' command.", c));
        }
    }

    // This is needed, probably because the calculator is pretty slow.
    thread::sleep(Duration::from_millis(500));
    // Initiate first packet from calculator by sending NAK
    putc(port, NAK).context("Error: failed to write initial NAK.")?;

    let mut packet_buf = vec![0; 1 + 2 + 1024 + 1];
    let mut packet_counter = 1u32;

    loop {
        // Also needed, as far as I can tell.
        thread::sleep(Duration::from_millis(300));
		let hdr = getc(port)?;
		eprint!("{:?}", hdr as u8);
		let packet_len = match hdr {
			SOH => 128,
			STX => 1024,
			EOT => {
				putc(port, ACK).context("Error: failed to write ACK for EOT.")?;
				break;
			},
			CAN => {
				return Err(anyhow::anyhow!("Received cancel from remote side."));
			},
			_ => {
				eprintln!("Unknown header {:?}, sending NAK.", hdr);
				putc(port, NAK).context("Error: failed to write NAK for unknown header.")?;
				continue;
			},
		};
		let pkt_counter = getc(port)?;
		let pkt_counter_inv = getc(port)?;
		if pkt_counter != 255 - pkt_counter_inv {
			putc(port, NAK).context("Error: failed to write NAK for packet counter.")?;			
			continue;
		}
		if packet_counter != pkt_counter as u32 {
			eprintln!("Packet counter mismatch: expected {:?}, got {:?}.", packet_counter, pkt_counter);
			putc(port, NAK).context("Error: failed to write NAK for packet counter.")?;
			continue;
		}
		port.read_exact(packet_buf[0..packet_len + 1].as_mut()).context("Error: failed to read packet.")?;
        // print_hexdump(&packet_buf[0..packet_len+1]);

        // verify checksum of this packet
        let mut checksum = 0u32;
        for i in &packet_buf[0..packet_len] {
            checksum += *i as u32;
        }

        if checksum as u8 == packet_buf[packet_len] {
			putc(port, ACK).context("Error: failed to write ACK for packet.")?;
            file_contents.extend_from_slice(&packet_buf[0..packet_len]);
        } else {
			println!("calculated checksum is {:#x}, packet checksum is {:#x}", checksum as u8, packet_buf[packet_len]);
            // currently untested...
            eprintln!(
                "Checksum failed for packet {:?}, sending NAK and trying again.",
                packet_counter
            );
			putc(port, NAK).context("Error: failed to write NAK for packet.")?;
            continue; // skip packet counter increment
        }

        packet_counter += 1;
		println!("packet_counter is {:?} size is {}", packet_counter, file_contents.len());
    }
	// print_hexdump(&file_contents);
	// Remove trailing 0x00 bytes from file_contents
	while let Some(&0x00) = file_contents.last() {
		file_contents.pop();
	}

    match file.write_all(&file_contents) {
        Ok(_) => {}
        Err(e) => {
            crate::helpers::error_handler(format!("Error: failed to write to output file: {:?}", e))
        }
    }

    if *finish {
        finish_server(port);
    }

    pb.finish_with_message(format!(
        "Receiving {:?} from {}...{} Got {:?} {}.",
        style(path.file_name().unwrap()).yellow().bright(),
        style(port.name().unwrap()).green().bright(),
        style("done!").green().bright(),
        packet_counter,
        match packet_counter {
            1 => "packet",
            _ => "packets",
        }
    ));

    return Ok(final_path); // used in main for crc calculation
}
